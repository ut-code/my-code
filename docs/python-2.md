# 第2章: Pythonの基本構文とデータ型

他の言語での経験を活かし、Pythonの基本的な文法と組み込み型を素早くキャッチアップしましょう。特に、多くの静的型付け言語と異なる**インデントによるブロック表現**と**動的型付け**は、Pythonを理解する上で最初の重要なポイントです。

## インデントが持つ意味: 波括弧 `{}` からの解放

多くのプログラミング言語では、`if`文や`for`ループなどのコードブロックを波括弧 `{}` で囲みます。しかし、**Pythonではインデント（字下げ）そのものがコードブロックを定義します**。これはPythonの構文における最大の特徴の一つです。

一般的に、インデントには**スペース4つ**を使用することが強く推奨されています（PEP 8スタイルガイド）。

**Java/C++でのブロック表現:**

```java
if (score > 80) {
    System.out.println("合格です。");
    System.out.println("おめでとうございます！");
}
```

**Pythonでのブロック表現:**

```python
score = 85
if score > 80:
    # このブロックはインデントによって定義される
    print("合格です。")
    print("おめでとうございます！")

print("処理終了") # インデントが戻ると、ifブロックの外側
```

インデントを間違えると `IndentationError` という文法エラーが発生します。これにより、誰が書いてもコードの見た目が統一され、可読性が高まるというメリットがあります。

## 変数宣言と動的型付け

静的型付け言語（Java, C++, C\#など）に慣れている方にとって、Pythonの変数宣言は非常にシンプルに感じられるでしょう。

**Pythonでは、変数の型を事前に宣言する必要はありません**。変数への代入が初めて行われたときに、変数が作成され、代入された値の型が自動的にその変数の型となります。これを**動的型付け**と呼びます。

```python
# 変数 `count` は整数(int)型として自動的に解釈される
count = 100
print(f"値: {count}, 型: {type(count)}")

# 同じ変数に別の型（文字列）を再代入できる
count = "百"
print(f"値: {count}, 型: {type(count)}")
```

上記の例のように、`count` という同じ名前の変数に、最初は整数を、次に文字列を代入できます。`type()` 関数は、変数が現在どの型を持っているかを確認するのに便利です。

## 基本的なデータ型

ここでは、プログラミングで頻繁に使用される基本的なデータ型を紹介します。

### 数値 (`int`, `float`)

Pythonには整数 (`int`) と浮動小数点数 (`float`) があります。型の区別は自動的に行われます。

```python
# 整数 (int)
x = 10

# 浮動小数点数 (float)
y = 3.14

# 演算
print(x + y)  # 結果は float になる -> 13.14
print(x * 2)  # -> 20
print(x / 3)  # 通常の除算 -> 3.333...
print(x // 3) # 整数の除算（切り捨て） -> 3
print(x % 3)  # 剰余 -> 1
print(x ** 3) # べき乗 -> 1000
```

### 文字列 (`str`)

文字列はシングルクォート `'` またはダブルクォート `"` で囲みます。どちらを使っても機能的な違いはありません。

```python
message1 = "こんにちは、世界"
message2 = 'Hello, World!'

# 文字列の連結
greeting = message1 + " & " + message2
print(greeting)

# 文字列の繰り返し
separator = "-" * 10
print(separator) # -> ----------
```

**f-stringによるフォーマット**
他の言語での文字列フォーマット（`printf` や `String.format`）に相当するものとして、Python 3.6以降では**f-string**が推奨されます。非常に直感的で強力です。

文字列の前に `f` を置き、波括弧 `{}` の中に変数名や式を直接記述できます。

```python
name = "佐藤"
age = 28
point = 88.5

# 従来の方法（少し面倒）
# print("名前: " + name + ", 年齢: " + str(age) + "点")

# f-string を使った方法（推奨✨）
profile = f"名前: {name}, 年齢: {age}, 点数: {point}"
print(profile) # -> 名前: 佐藤, 年齢: 28, 点数: 88.5

# f-string内では計算も可能
print(f"{name}さんは10年後、{age + 10}歳です。")
```

### 真偽値 (`bool`)

真偽値は `True` または `False` の2つの値を持ちます。**先頭が大文字であることに注意してください**。

```python
is_active = True
is_admin = False

# 論理演算子 (and, or, not)
print(f"Active AND Admin: {is_active and is_admin}") # -> False
print(f"Active OR Admin:  {is_active or is_admin}")  # -> True
print(f"NOT Active:       {not is_active}")         # -> False
```

## 型ヒント (Type Hints) の紹介

動的型付けはコードを素早く書ける一方で、大規模なプロジェクトやチーム開発では、関数がどのような型の引数を期待し、何を返すのかが分かりにくくなることがあります。

そこでPython 3.5から導入されたのが**型ヒント**です。これは、変数や関数の引数、戻り値に「期待される型」を注釈として付与する機能です。

**重要**: 型ヒントはあくまで「ヒント」であり、Pythonのインタプリタはこれを**実行時に強制しません**。しかし、エディタや静的解析ツール（MyPyなど）がこのヒントを解釈し、型の不一致を開発段階で警告してくれるため、コードの可読性と堅牢性が大幅に向上します。

```python
# nameはstr型、ageはint型を期待し、戻り値はstr型であることを示す
def create_user_profile(name: str, age: int) -> str:
    return f"ユーザー名: {name}, 年齢: {age}"

# 正しい使い方
user1 = create_user_profile("田中", 35)
print(user1)

# 変数にも型ヒントを付けられる
user_id: int = 101

# --- 型ヒントに反する使い方 ---
# 警告が出る可能性があるが、実行はできてしまう
user2 = create_user_profile("鈴木", "25歳") # ageに文字列を渡している
print(user2) # -> ユーザー名: 鈴木, 年齢: 25歳
```

静的型付け言語の経験者にとって、型ヒントは馴染みやすく、動的言語の柔軟性と静的解析の安全性を両立させるための強力なツールとなるでしょう。

-----

この章では、Pythonの構文の基礎となるインデントルール、柔軟な動的型付け、そして基本的なデータ型について学びました。特にf-stringと型ヒントは、モダンなPython開発における必須知識です。

次の章では、複数の要素をまとめて扱うための強力なデータ構造である**リスト**と**タプル**について詳しく見ていきます。