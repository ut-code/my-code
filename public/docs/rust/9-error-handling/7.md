---
id: rust-error-handling-7
title: エラーの伝播（? 演算子）
level: 2
---

## エラーの伝播（`?` 演算子）

関数内でエラーが発生した際、その場で処理せずに呼び出し元へエラーを返したいことがよくあります。これを「エラーの伝播（propagation）」と呼びます。

Rustにはこれを劇的に短く書くための **`?` 演算子** があります。

  * `Result` 値の後ろに `?` を置く。
  * 値が `Ok` なら、中身を取り出して処理を続行。
  * 値が `Err` なら、**その関数から即座に `return Err(...)` する。**

<!-- end list -->

```rust:error_propagation.rs
use std::num::ParseIntError;

// 文字列を受け取り、最初の文字を切り出して数値に変換し、10倍して返す
fn get_first_digit_scaled(text: &str) -> Result<i32, String> {
    // 1. 文字列が空の場合のエラー処理
    let first_char = text.chars().next().ok_or("空の文字列です".to_string())?;

    // 2. 文字を数値にパース（失敗したらエラー伝播）
    // ParseIntError を String に変換するために map_err を使用しています
    // (?演算子はFromトレイトを使って自動変換を行いますが、ここでは単純化のため手動変換します)
    let num: i32 = first_char.to_string()
        .parse()
        .map_err(|_| format!("'{}' は数値ではありません", first_char))?;

    Ok(num * 10)
}

fn main() {
    match get_first_digit_scaled("5 apples") {
        Ok(v) => println!("計算結果: {}", v),
        Err(e) => println!("エラー発生: {}", e),
    }

    match get_first_digit_scaled("banana") {
        Ok(v) => println!("計算結果: {}", v),
        Err(e) => println!("エラー発生: {}", e),
    }
}
```

```rust-exec:error_propagation.rs
計算結果: 50
エラー発生: 'b' は数値ではありません
```

`?` 演算子を使うことで、`match` のネスト地獄（右方向へのドリフト）を防ぎ、コードの流れを「成功ルート」を中心に記述できます。
