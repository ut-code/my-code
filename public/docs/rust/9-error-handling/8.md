---
id: rust-error-handling-8
title: カスタムエラー型の定義
level: 2
---

## カスタムエラー型の定義

ライブラリや大規模なアプリケーションを作る場合、`String` 型のエラーでは情報が不足します。Rustでは `std::error::Error` トレイトを実装した独自の型（通常は Enum）を定義するのが一般的です。

Rustのエコシステムでは、ボイラープレート（定型コード）を減らすために **`thiserror`** というクレートが非常に人気ですが、ここでは仕組みを理解するために標準機能だけで実装してみます。

```rust:custom_error.rs
use std::fmt;

// 1. 独自のエラー型を定義
#[derive(Debug)]
enum MyToolError {
    IoError(String),
    ParseError(String),
    LogicError,
}

// 2. Display トレイトの実装（ユーザー向けのエラーメッセージ）
impl fmt::Display for MyToolError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MyToolError::IoError(msg) => write!(f, "IOエラー: {}", msg),
            MyToolError::ParseError(msg) => write!(f, "解析エラー: {}", msg),
            MyToolError::LogicError => write!(f, "ロジックエラーが発生しました"),
        }
    }
}

// 3. Error トレイトの実装（これを実装することで、Rustのエラーエコシステムと統合される）
impl std::error::Error for MyToolError {}

// 使用例
fn dangerous_operation(input: i32) -> Result<String, MyToolError> {
    match input {
        0 => Err(MyToolError::IoError("ディスク書き込み失敗".into())),
        1 => Err(MyToolError::ParseError("不正なヘッダ".into())),
        2 => Err(MyToolError::LogicError),
        _ => Ok("成功！".into()),
    }
}

fn main() {
    let results = [dangerous_operation(0), dangerous_operation(3)];
    
    for res in results {
        match res {
            Ok(s) => println!("結果: {}", s),
            Err(e) => println!("失敗: {}", e), // Displayの実装が使われる
        }
    }
}
```

```rust-exec:custom_error.rs
失敗: IOエラー: ディスク書き込み失敗
結果: 成功！
```

**補足:** `thiserror` クレートを使うと、上記の `impl fmt::Display` などをマクロで自動生成でき、以下のように簡潔に書けます（参考情報）。

```rust
// thiserrorを使った場合のイメージ
#[derive(thiserror::Error, Debug)]
enum MyToolError {
    #[error("IOエラー: {0}")]
    IoError(String),
    // ...
}
```
