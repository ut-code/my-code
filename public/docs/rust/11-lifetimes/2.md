---
id: rust-lifetimes-2
title: 関数のライフタイム注釈
level: 2
---

## 関数のライフタイム注釈

最も頻繁にライフタイム注釈が必要になるのは、**「引数として参照を受け取り、戻り値として参照を返す関数」**です。

2つの文字列スライスを受け取り、長い方を返す関数 `longest` を考えてみましょう。

```rust:longest_fail.rs
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

このコードをコンパイルしようとすると、以下のようなエラーが出ます。

```rust-exec:longest_fail.rs
error[E0106]: missing lifetime specifier
   |
1  | fn longest(x: &str, y: &str) -> &str {
   |               ----     ----     ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
```

**なぜエラーになるのか？**
コンパイラには、`longest` 関数が `x` を返すのか `y` を返すのか実行時まで分かりません。そのため、**戻り値の参照がいつまで有効であれば安全なのか（xの寿命に合わせるべきか、yの寿命に合わせるべきか）** を判断できないのです。
