---
id: rust-lifetimes-3
title: ライフタイム注釈の構文
level: 3
---

### ライフタイム注釈の構文

ここで**ジェネリックなライフタイム注釈**が登場します。
構文は `'a` のようにアポストロフィから始まる名前を使います。通常は `'a`（a, b, c...）が使われます。

注釈のルールは以下の通りです：

  * 関数名の後に `<'a>` でライフタイムパラメータを宣言する。
  * 引数と戻り値の参照に `&'a str` のように付与する。

修正したコードがこちらです。

```rust:longest_success.rs
// 'a というライフタイムを宣言し、
// 「引数x、引数y、そして戻り値は、すべて少なくとも 'a と同じ期間だけ生きている」
// という制約をコンパイラに伝える。
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        // resultのライフタイムは、string1とstring2のうち「短い方」の寿命に制約される
        result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is '{}'", result);
    }
    // ここで string2 がドロップされるため、result も無効になる。
    // もしここで result を使おうとするとコンパイルエラーになる（安全！）。
    // println!("The longest string is '{}'", result);
}
```

```rust-exec:longest_success.rs
The longest string is 'long string is long'
```

**重要なポイント:**
ライフタイム注釈 `'a` は、変数の寿命を**延ばすものではありません**。
「複数の参照の寿命の関係性」をコンパイラに説明し、**「渡された参照の中で最も寿命が短いもの」** に戻り値の寿命を合わせるように制約するものです。
