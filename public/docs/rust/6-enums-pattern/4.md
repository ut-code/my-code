---
id: rust-enums-pattern-4
title: なぜこれが安全なのか？
level: 3
---

### なぜこれが安全なのか？

`Option<T>` 型と `T` 型（例えば `i32`）は異なる型です。そのため、**「値がないかもしれないもの」を、チェックせずにそのまま計算に使うことがコンパイラレベルで禁止されます。**

```rust:option_intro.rs
fn main() {
    let some_number = Some(5);
    let some_string = Some("a string");

    // Noneの場合は型推論できないため、明示的に型を指定する必要がある
    let absent_number: Option<i32> = None;

    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    // 以下の行はコンパイルエラーになります。
    // i8 と Option<i8> は足し算できません。
    // let sum = x + y; 

    println!("x: {}", x);
    // 値を取り出すには明示的な処理が必要（後述のmatchなどを使う）
    println!("y is: {:?}", y);
    println!("absent is: {:?}", absent_number);
}
```

```rust-exec:option_intro.rs
x: 5
y is: Some(5)
absent is: None
```

値を使うためには、`Option<T>` から `T` を取り出す処理（Nullチェックに相当）を必ず書かなければなりません。これにより、「うっかりNullを参照してクラッシュ」という事故を防げます。
