---
id: cpp-stl-algorithms-0
title: イテレータ：コンテナとアルゴリズムを繋ぐ架け橋
level: 2
---

## イテレータ：コンテナとアルゴリズムを繋ぐ架け橋

アルゴリズムは、特定のコンテナ（`std::vector` や `std::list` など）に直接依存しないように設計されています。では、どうやってコンテナ内の要素にアクセスするのでしょうか？そこで登場するのが**イテレータ (Iterator)** です。

イテレータは、コンテナ内の要素を指し示す「ポインタのような」オブジェクトです。ポインタのように `*` で要素の値を参照したり、`++` で次の要素に進んだりできます。

ほとんどのコンテナは、以下の2つの重要なイテレータを取得するメンバ関数を持っています。

  * `begin()`: コンテナの先頭要素を指すイテレータを返す。
  * `end()`: コンテナの**最後の要素の次**を指すイテレータを返す。これは有効な要素を指していない「番兵」のような役割を果たします。

アルゴリズムは、この `begin()` と `end()` から得られるイテレータのペアを使い、操作対象の「範囲」を指定します。範囲は半開区間 `[begin, end)` で表され、`begin` が指す要素は範囲に含まれ、`end` が指す要素は含まれません。

簡単な例を見てみましょう。イテレータを使って `vector` の全要素を表示するコードです。

```cpp:iterator_example.cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {0, 1, 2, 3, 4};

    // イテレータを使ってコンテナを走査
    std::cout << "Numbers: ";
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        std::cout << *it << " "; // *it で要素の値にアクセス
    }
    std::cout << std::endl;

    // C++11以降の範囲ベースforループ (内部ではイテレータが使われている)
    std::cout << "Numbers (range-based for): ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

```cpp-exec:iterator_example.cpp
Numbers: 0 1 2 3 4 
Numbers (range-based for): 0 1 2 3 4 
```

このように、イテレータはコンテナの種類を問わず、統一的な方法で要素にアクセスする仕組みを提供します。これが、アルゴリズムが様々なコンテナに対して汎用的に機能する理由です。
