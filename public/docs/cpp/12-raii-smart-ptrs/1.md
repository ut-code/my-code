---
id: cpp-raii-smart-ptrs-1
title: 例外とリソースリーク
level: 3
---

### 例外とリソースリーク

ここで、`new` と `delete` を使った手動のメモリ管理と例外処理が組み合わさると、問題が発生します。

```cpp:raw_pointer_problem.cpp
#include <iostream>
#include <stdexcept>

void process_data() {
    int* data = new int[100]; // リソース確保
    std::cout << "Data allocated." << std::endl;

    // 何らかの処理...
    bool something_wrong = true;
    if (something_wrong) {
        throw std::runtime_error("Something went wrong during processing!");
    }

    // 例外が投げられると、この行には到達しない
    std::cout << "Deleting data..." << std::endl;
    delete[] data; // リソース解放
}

int main() {
    try {
        process_data();
    } catch (const std::runtime_error& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    // process_data内で確保されたメモリは解放されないままである！
    return 0;
}
```

```cpp-exec:raw_pointer_problem.cpp
Data allocated.
Error: Something went wrong during processing!
```

この例では、`process_data` 関数内で `throw` が実行されると、関数の実行が中断され `catch` ブロックにジャンプします。その結果、`delete[] data;` の行が実行されず、確保されたメモリが解放されない**メモリリーク**が発生します。

この問題を解決するのが、C++の最も重要な設計思想の一つである **RAII** です。
