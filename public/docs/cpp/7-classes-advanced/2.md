---
id: cpp-classes-advanced-2
title: 解決策：コピー機能を自作する (深いコピー)
level: 3
---

### 解決策：コピー機能を自作する (深いコピー)

この問題を解決するために、**コピーコンストラクタ**と**コピー代入演算子**を自分で定義して、「深いコピー」を実装します。深いコピーとは、ポインタの指す先の実体（データそのもの）を新しく作ってコピーすることです。

```cpp:resource_holder.cpp
#include <iostream>

class ResourceHolder {
private:
    int* m_data; // リソースとして動的に確保したintへのポインタ

public:
    // コンストラクタ: intを1つ動的に確保し、値を設定
    ResourceHolder(int value) {
        m_data = new int(value);
        std::cout << "Resource " << *m_data << " created. (at " << m_data << ")" << std::endl;
    }

    // デストラクタ: 確保したメモリを解放
    ~ResourceHolder() {
        if (m_data != nullptr) {
            std::cout << "Resource " << *m_data << " destroyed. (at " << m_data << ")" << std::endl;
            delete m_data;
        }
    }

    // --- ここからが本題です ---

    // 1. コピーコンストラクタ (深いコピー)
    // ResourceHolder r2 = r1; のように、オブジェクトの作成と同時にコピーするときに呼ばれる
    ResourceHolder(const ResourceHolder& other) {
        // ① 新しいメモリを確保する
        // ② otherの「値」(*other.m_data)を、新しいメモリにコピーする
        m_data = new int(*other.m_data);
        std::cout << "COPY CONSTRUCTOR: New resource " << *m_data << " created. (at " << m_data << ")" << std::endl;
    }

    // 2. コピー代入演算子 (深いコピー)
    // r3 = r1; のように、既存のオブジェクトに代入するときに呼ばれる
    ResourceHolder& operator=(const ResourceHolder& other) {
        std::cout << "COPY ASSIGNMENT OPERATOR called." << std::endl;

        // ① 自己代入のチェック (a = a; のような無駄な処理を防ぐ)
        if (this == &other) {
            return *this; // 何もせず自分自身を返す
        }

        // ② 自分が元々持っていた古いリソースを解放する
        delete m_data;

        // ③ 新しいリソースを確保し、相手の値をコピーする
        m_data = new int(*other.m_data);

        return *this; // 自分自身を返すことで、a = b = c; のような連続代入が可能になる
    }

    void print() const {
        std::cout << "Value: " << *m_data << ", Address: " << m_data << std::endl;
    }
};

int main() {
    std::cout << "--- rh1の作成 ---" << std::endl;
    ResourceHolder rh1(10);

    std::cout << "\n--- rh2をrh1で初期化 ---" << std::endl;
    ResourceHolder rh2 = rh1; // コピーコンストラクタが呼ばれる

    std::cout << "\n--- rh3の作成 ---" << std::endl;
    ResourceHolder rh3(20);

    std::cout << "\n--- rh3にrh1を代入 ---" << std::endl;
    rh3 = rh1; // コピー代入演算子が呼ばれる

    std::cout << "\n--- 各オブジェクトの状態 ---" << std::endl;
    std::cout << "rh1: "; rh1.print();
    std::cout << "rh2: "; rh2.print(); // rh1とは別のメモリを持っている
    std::cout << "rh3: "; rh3.print(); // rh1とは別のメモリを持っている

    std::cout << "\n--- main関数終了 ---" << std::endl;
    return 0; // ここでrh1, rh2, rh3のデストラクタが呼ばれ、それぞれが確保したメモリを安全に解放する
}
```

```cpp-exec:resource_holder.cpp
--- rh1の作成 ---
Resource 10 created. (at 0x139f065e0)

--- rh2をrh1で初期化 ---
COPY CONSTRUCTOR: New resource 10 created. (at 0x139f06600)

--- rh3の作成 ---
Resource 20 created. (at 0x139f06620)

--- rh3にrh1を代入 ---
COPY ASSIGNMENT OPERATOR called.

--- 各オブジェクトの状態 ---
rh1: Value: 10, Address: 0x139f065e0
rh2: Value: 10, Address: 0x139f06600
rh3: Value: 10, Address: 0x139f06640

--- main関数終了 ---
Resource 10 destroyed. (at 0x139f06640)
Resource 10 destroyed. (at 0x139f06600)
Resource 10 destroyed. (at 0x139f065e0)
```

*(メモリアドレスは実行するたびに変わります)*

実行結果を見ると、`rh1`, `rh2`, `rh3` はそれぞれ異なるメモリアドレス (`Address`) を持っていることがわかります。これにより、各オブジェクトは独立したリソースを管理でき、プログラム終了時にそれぞれのデストラクタが安全にメモリを解放できます。

| 機能 | いつ呼ばれるか | 何をするか |
| :--- | :--- | :--- |
| **コピーコンストラクタ** | オブジェクトが**作られる時**に、他のオブジェクトで初期化される場合<br>`ResourceHolder r2 = r1;` | 新しいリソースを確保し、元のオブジェクトの**値**をコピーする。 |
| **コピー代入演算子** | **既にあるオブジェクト**に、他のオブジェクトを代入する場合<br>`r3 = r1;` | 1. 自分が持っている古いリソースを解放する。<br>2. 新しいリソースを確保し、元のオブジェクトの**値**をコピーする。 |

このように、ポインタでリソースを管理するクラスでは、安全なコピーを実現するためにこの2つの関数を自分で定義することが不可欠です。
