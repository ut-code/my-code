# 第2章: C++の型システムとメモリ

C++は**静的型付け言語**です。これは、コンパイル時にすべての変数の型が決定され、一度決まった型は変更できないことを意味します。この厳密な型システムは、一見すると面倒に感じるかもしれませんが、大規模なプログラムでもバグを未然に防ぎ、高いパフォーマンスを引き出すための重要な仕組みです。

この章では、C++の基本的な型と、他の高級言語ではあまり意識することのない「メモリ」との関係について学んでいきましょう。

## 基本データ型

他の多くの言語と同様に、C++にも数値を扱うための基本的なデータ型が用意されています。すでにご存知のものが多いと思いますが、C++における特徴と合わせて再確認しましょう。

| 型 (Type)       | 説明 (Description)                               | サイズの例 (Typical Size) | 値の範囲の例 (Example Range)                           |
| :---------------- | :----------------------------------------------- | :---------------------- | :------------------------------------------------------- |
| `int`             | 整数を格納します (Integer)                     | 4 bytes                 | `-2,147,483,648` ～ `2,147,483,647`                     |
| `double`          | 倍精度浮動小数点数を格納します (Double-precision float) | 8 bytes                 | 約 `±1.7E308` (有効数字15桁程度)                         |
| `char`            | 1文字を格納します (Character)                  | 1 byte                  | `-128` ～ `127` または `0` ～ `255`                     |
| `bool`            | 真偽値を格納します (Boolean)                   | 1 byte                  | `true` または `false`                                    |

**ポイント**: C++の規格では、`int`が何バイトであるかといったサイズを厳密には定めていません。環境（OSやCPUアーキテクチャ）によって変わる可能性があります。しかし、多くのモダンな環境では上記のサイズが一般的です。

### 変数の宣言・代入・初期化

変数は、値を入れておくための「名前付きの箱」のようなものです。C++で変数を使うには、まず「どのような種類の箱（**型**）を、どんな名前で用意するか」をコンピュータに伝える必要があります。これを**宣言 (Declaration)** と呼びます。

```cpp
// 整数を入れるための'age'という名前の箱を宣言
int age;
```

宣言した変数に値を入れることを**代入 (Assignment)** と言います。代入には `=` 記号を使います。

```cpp
// 宣言済みの変数 'age' に 30 を代入
age = 30;
```

多くの場合、宣言と代入は同時に行います。これを**初期化 (Initialization)** と呼び、こちらの書き方が一般的で安全です。

```cpp:data_types.cpp
#include <iostream>

int main() {
    // 宣言と同時に初期化
    int age = 30;
    double pi = 3.14159;
    char initial = 'A';
    bool is_student = true;

    std::cout << "Age: " << age << std::endl;
    std::cout << "Pi: " << pi << std::endl;
    std::cout << "Initial: " << initial << std::endl;
    std::cout << "Is student? " << is_student << std::endl; // boolは通常 1 (true) または 0 (false) として出力される

    return 0;
}
```

```cpp-exec:data_types.cpp
Age: 30
Pi: 3.14159
Initial: A
Is student? 1
```

## 基本的な演算

C++では、数値型の変数を使って基本的な算術計算ができます。

| 演算子 | 意味 | 例 | 結果 |
|:---:|:---|:---|:---:|
| `+` | 加算 | `5 + 2` | `7` |
| `-` | 減算 | `5 - 2` | `3` |
| `*` | 乗算 | `5 * 2` | `10` |
| `/` | 除算 | `5 / 2` | `2` |
| `%` | 剰余 | `5 % 2` | `1` |

### ⚠️ 整数除算の注意点

ここで特に注意が必要なのが `/` (除算) です。**整数 (`int`) 同士の割り算の結果は、小数点以下が切り捨てられ、整数 (`int`) になります。**

```cpp:integer_division.cpp
#include <iostream>

int main() {
    int a = 7;
    int b = 2;

    std::cout << "7 / 2 = " << a / b << std::endl;

    // 正しい計算結果（浮動小数点数）を得るには？
    // 演算する値の少なくとも一方が浮動小数点数型である必要があります。
    double c = 7.0;
    std::cout << "7.0 / 2 = " << c / b << std::endl;

    return 0;
}
```

```cpp-exec:integer_division.cpp
7 / 2 = 3
7.0 / 2 = 3.5
```

`7 / 2` が `3` になってしまうのは、`int` 型の `a` と `int` 型の `b` で演算した結果もまた `int` 型になる、というC++のルールのためです。小数点以下の値を得たい場合は、`7.0` のように、どちらかの値を `double` などの浮動小数点数型にする必要があります。

## 型を厳密に扱う

静的型付けの恩恵を最大限に受けるために、C++には型をより安全かつ便利に扱うための仕組みがあります。

### `const`による不変性の保証

`const` (constantの略) は、変数を**読み取り専用**にするためのキーワードです。一度`const`で初期化された変数の値は、後から変更しようとするとコンパイルエラーになります。

なぜ`const`が重要なのでしょうか？

  * **安全性の向上**: 変更されるべきでない値を誤って変更してしまうバグを防ぎます。
  * **意図の明確化**: プログラムを読む人に対して、「この値は変わらない」という意図を明確に伝えられます。

円周率のように、プログラム中で決して変わることのない値に`const`を使うのが典型的な例です。

```cpp:const_example.cpp
#include <iostream>

int main() {
    const double PI = 3.14159;
    int radius = 5;

    double area = PI * radius * radius;
    std::cout << "Area: " << area << std::endl;

    // PI = 3.14; // この行はコンパイルエラーになる！

    return 0;
}
```
```cpp-exec:const_example.cpp
Area: 78.5397
```

### `auto`による型推論

C++11から導入された`auto`キーワードを使うと、コンパイラが初期化式から変数の型を自動で推論してくれます。これにより、特に型名が長い場合にコードを簡潔に書くことができます。

```cpp
// autoを使わない場合
std::vector<int>::iterator it = my_vector.begin();

// autoを使う場合
auto it = my_vector.begin(); // コンパイラが it の型を std::vector<int>::iterator と推論してくれる
```

ただし、`auto`はあくまで「型を書く手間を省く」ものであり、変数が型を持たないわけではありません（動的型付け言語とは異なります）。初期化と同時に使う必要があり、型が明確な場面で適切に使うことが推奨されます。

```cpp
auto x = 10;       // x は int型になる
auto y = 3.14;     // y は double型になる
auto z = "hello";  // z は const char* (C言語スタイルの文字列) になるので注意
```

## C++の文字列: `std::string`

C言語では文字列を`char`の配列（`char*`）として扱いましたが、これは扱いにくく、バグの温床でした。モダンC++では、**`std::string`** クラスを使うのが標準的です。`std::string`は、文字列の連結、長さの取得、部分文字列の取り出しといった操作を安全かつ簡単に行うための豊富な機能を提供します。

`std::string`を使うには、`<string>`ヘッダをインクルードする必要があります。

```cpp:string_example.cpp
#include <iostream>
#include <string> // std::string を使うために必要

int main() {
    // 文字列の宣言と初期化
    std::string greeting = "Hello";

    // 文字列の連結
    std::string name = "C++";
    std::string message = greeting + ", " + name + "!";

    std::cout << message << std::endl;

    // 文字列の長さを取得
    std::cout << "Length: " << message.length() << std::endl;

    return 0;
}
```

```cpp-exec:string_example.cpp
Hello, C++!
Length: 11
```

## 変数とメモリ

さて、C++を深く理解する上で避けて通れないのが**メモリ**の概念です。変数を宣言すると、コンピュータのメモリ上にその型に応じたサイズの領域が確保されます。

例えば、`int x = 10;` と書くと、

1.  コンパイラは`int`型に必要なメモリサイズ（例: 4バイト）を判断します。
2.  プログラム実行時、メモリ上のどこかに4バイトの領域が確保されます。
3.  その領域に`x`という名前が割り当てられ、値として`10`が格納（バイナリ形式で書き込み）されます。

この「メモリ上のどこか」を示すのが**メモリアドレス**（単にアドレスとも）です。アドレスは、メモリ上の各バイトに割り振られた通し番号のようなもので、通常は16進数で表現されます。

変数名の前に`&`（アドレス演算子）を付けることで、その変数が格納されているメモリアドレスを知ることができます。

```cpp:memory_address.cpp
#include <iostream>
#include <string>

int main() {
    int age = 30;
    double pi = 3.14;
    std::string name = "Alice";

    std::cout << "変数 'age' の値: " << age << std::endl;
    std::cout << "変数 'age' のメモリアドレス: " << &age << std::endl;
    std::cout << std::endl;

    std::cout << "変数 'pi' の値: " << pi << std::endl;
    std::cout << "変数 'pi' のメモリアドレス: " << &pi << std::endl;
    std::cout << std::endl;

    std::cout << "変数 'name' の値: " << name << std::endl;
    std::cout << "変数 'name' のメモリアドレス: " << &name << std::endl;

    return 0;
}
```
```cpp-exec:memory_address.cpp
変数 'age' の値: 30
変数 'age' のメモリアドレス: 0x7ffee3b8c9ac

変数 'pi' の値: 3.14
変数 'pi' のメモリアドレス: 0x7ffee3b8c9a0

変数 'name' の値: Alice
変数 'name' のメモリアドレス: 0x7ffee3b8c990
```

このコードを実行すると、`0x7ffee...` のようなアドレスが表示されるはずです（値は実行のたびに変わります）。今は「変数はメモリ上の特定の場所に、特定のサイズで存在している」というイメージを持つことが重要です。この概念は、第4章で学ぶポインタを理解するための基礎となります。

## この章のまとめ

  * C++は**静的型付け言語**であり、コンパイル時にすべての変数の型が決まる。
  * `int`, `double`, `char`, `bool` といった基本的なデータ型が存在する。
  * 変数は**宣言**してから使い、宣言と同時に値を代入する**初期化**が一般的。
  * 基本的な**四則演算**ができるが、**整数同士の除算**は結果が整数に切り捨てられる点に注意。
  * **`const`** を使うことで、変数を不変にし、プログラムの安全性を高めることができる。
  * **`auto`** を使うことで、コンパイラに型を推論させ、コードを簡潔に書くことができる。
  * モダンC++では、文字列は\*\*`std::string`\*\* クラスを使って安全かつ便利に扱う。
  * 宣言された変数は、メモリ上の特定の**アドレス**に、その型に応じた**サイズ**の領域を確保して格納される。

### 練習問題1

あなたの名前（`std::string`）、年齢（`int`）、視力（`double`）をそれぞれ変数として宣言し、コンソールに出力するプログラムを書いてください。ただし、名前は一度決めたら変わらないものとして、`const`を使って宣言してください。

```cpp:practice2_1.cpp
#include <iostream>
#include <string>

int main() {

}
```

```cpp-exec:practice2_1.cpp
```


### 練習問題2

2つの`std::string`変数 `firstName` と `lastName` を宣言し、あなたの姓名で初期化してください。その後、これら2つの変数を連結してフルネームを`fullName`という新しい変数に格納し、そのフルネームと文字数（長さ）をコンソールに出力するプログラムを書いてください。

```cpp:practice2_2.cpp
#include <iostream>
#include <string>

int main() {

}
```

```cpp-exec:practice2_2.cpp
```
